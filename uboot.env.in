arch=arm
baudrate=115200
board=dragonboard
board_name=dragonboard
bootcmd=echo ENVCMD; run snappy_boot
bootfile=dragonboard/linux.itb
bootdelay=0
cpu=armv8
dl_kernel=tftp $linux_addr $linux_image && tftp $fdt_addr $fdt_image
dl_ramdisk=tftp $ramdisk_addr $ramdisk_image
dl_uboot=tftp $loadaddr dragonboard/u-boot.img
fdt_addr=0x83000000
fdt_high=0xffffffffffffffff
fdt_image=dragonboard/apq8016-sbc.dtb
fdtfile=qcom/apq8016-sbc.dtb
filesize=7a00eb
getargs=if test "${load_device}" = "0:8";then fdt addr 0x81e00000;else if test "${load_device}" = "1:8";then fdt addr 0x81e00000;else fdt addr 0x83e00000;fi; fi; fdt get value args /chosen bootargs
initrd_file=initrd.img
initrd_high=0xffffffffffffffff
initrd_size=7a00eb
ipaddr=10.0.0.2
kernel_file=kernel.img
linux_addr=0x81000000
linux_image=dragonboard/Image
loadaddr=0x81000000
load_device=
check_load_device=if test -z "${load_device}";then if fatsize mmc 1:8 uboot.env;then setenv load_device "1:8";else if fatsize mmc 0:8 uboot.env;then setenv load_device "0:8";else setenv load_device "0:9";fi; fi;saveenv;fi;
loadfdt=fatload mmc ${load_device} ${fdt_addr} ${snap_kernel}/dtbs/${fdtfile}
loadfiles=run getargs; run check_load_device; run loadkernel; run loadfdt; run loadinitrd
loadinitrd=fatload mmc ${load_device} ${ramdisk_addr} ${snap_kernel}/${initrd_file}; setenv initrd_size ${filesize}
loadkernel=fatload mmc ${load_device} ${linux_addr} ${snap_kernel}/${kernel_file}
mmcargs=setenv bootargs "${args} console=ttyMSM0,115200n8 console=tty0 root=${mmcroot}"
nboot_nord=usb start && run dl_kernel && usb stop && booti $linux_addr - $fdt_addr
nboot_rd=usb start && run dl_kernel && run dl_ramdisk && booti $linux_addr $ramdisk_addr $fdt_addr
netmask=255.255.255.0
ramdisk_addr=0x84000000
ramdisk_image=dragonboard/initrd.img
reflash=mmc dev 0 &&usb start &&tftp $loadaddr dragonboard/rescue/gpt_both0.bin && mmc write $loadaddr 0 43 &&mmc rescan &&part start mmc 0 1 start && part size mmc 0 1 size && tftp $loadaddr dragonboard/rescue/NON-HLOS.bin &&mmc write $loadaddr $start $size &&part start mmc 0 2 start && part size mmc 0 2 size && tftp $loadaddr dragonboard/rescue/sbl1.mbn &&mmc write $loadaddr $start $size &&part start mmc 0 3 start && part size mmc 0 3 size && tftp $loadaddr dragonboard/rescue/rpm.mbn &&mmc write $loadaddr $start $size &&part start mmc 0 4 start && part size mmc 0 4 size && tftp $loadaddr dragonboard/rescue/tz.mbn &&mmc write $loadaddr $start $size &&part start mmc 0 5 start && part size mmc 0 5 size && tftp $loadaddr dragonboard/rescue/hyp.mbn &&mmc write $loadaddr $start $size &&part start mmc 0 6 start && part size mmc 0 6 size && tftp $loadaddr dragonboard/rescue/sec.dat &&mmc write $loadaddr $start $size &&part start mmc 0 7 start && part size mmc 0 7 size && tftp $loadaddr dragonboard/rescue/emmc_appsboot.mbn &&mmc write $loadaddr $start $size &&part start mmc 0 8 start && part size mmc 0 8 size && tftp $loadaddr dragonboard/u-boot.img &&mmc write $loadaddr $start $size &&usb stop &&echo Reflash completed
reflash_uboot=mmc dev 0 &&usb start &&part start mmc 0 8 start && setenv size 0x800  &&tftp $loadaddr dragonboard/u-boot.img &&mmc write $loadaddr $start $size &&usb stop &&echo Reflash completed &&reset
find_rescue=usb start; if fatsize usb 0:2 blobs/gpt_both0.bin; then setenv flash_device "usb 0:2 $loadaddr blobs/";else usb stop;mmc rescan; if mmc dev 1; fatsize mmc 1:8 blobs/gpt_both0.bin; then setenv flash_device "mmc 1:8 $loadaddr blobs";fi;fi
reflash_blobs=mmc dev 0 && fatload ${flash_device}/gpt_both0.bin && mmc write $loadaddr 0 43 && mmc rescan; setenv blobs "sbl1.mbn rpm.mbn tz.mbn hyp.mbn sec.dat emmc_appsboot.mbn emmc_u-boot.img"; setenv partn 1; for blob in $blobs; do part start mmc 0 $partn start; part size mmc 0 $partn size;fatload ${flash_device}/${blob};mmc write $loadaddr $start $size;setexpr partn $partn + 1; done; echo blobs reflash completed
chunk=0x10000
prepare_partition=part start mmc 0 $partn w_start; part start mmc 1 $partn r_start; part size mmc 1 $partn size; printenv r_start w_start size
copy_partition=while test 0x$size -ne 0x0; do mmc dev 1; if test 0x$size -gt $chunk; then setenv r_size $chunk; else setenv r_size 0x$size;fi; mmc read $loadaddr $r_start $r_size; mmc dev 0; mmc write $loadaddr $w_start $r_size;setexpr r_start 0x$r_start + $r_size; setexpr w_start 0x$w_start + $r_size; setexpr size 0x$size - $r_size; printenv r_start w_start size ;done
reflash_ubuntu=if test -z "${load_device}"; then run find_rescue && run reflash_blobs; while test 0x$partn -le 0x9; do run prepare_partition; run copy_partition; echo "part $partn replicated"; setexpr partn $partn + 1; done; echo "Ubuntu flashed to emmc"; else echo "Aborted!! use fresh sdcard image";fi
rootpath=/home/nfs/dragonboard
serverip=10.0.0.1
snappy_boot=if test "${snap_mode}" = "try"; then setenv snap_mode "trying"; saveenv; if test "${snap_try_core}" != ""; then setenv snap_core "${snap_try_core}"; fi; if test "${snap_try_kernel}" != ""; then setenv snap_kernel "${snap_try_kernel}"; fi; elif test "${snap_mode}" = "trying"; then setenv snap_mode ""; saveenv; fi; run loadfiles; setenv mmcroot "/dev/disk/by-label/writable ${snappy_cmdline} snap_core=${snap_core} snap_kernel=${snap_kernel}"; run mmcargs; booti ${linux_addr} ${ramdisk_addr}:${initrd_size} ${fdt_addr}
snappy_cmdline=net.ifnames=0 init=/lib/systemd/systemd ro rng_core.default_quality=700 panic=-1 fixrtc
snap_mode=
soc=apq8016
stderr=serial
stdin=serial
stdout=serial
test=run test_mmc && run test_sd && run test_sdm && run test_network && reset
test_mmc=mmc dev 0 && mmc erase 71020 1 && mmc write 0xBD956000 71020 1&& mmc read $fdt_addr 71020 1 && cmp.b 0xBD956000 $fdt_addr 200
test_network=usb start && dhcp; usb stop
test_sd=mmc dev 1 && mmc erase 61460 1 && mmc write 0xBD956000 61460 1&& mmc read $fdt_addr 61460 1 && cmp.b 0xBD956000 $fdt_addr 200
test_sdm=mmc dev 1 && mmc erase 61460 8 && mmc write 0xBD956000 61460 8&& mmc read $fdt_addr 61460 8 && cmp.b 0xBD956000 $fdt_addr 1000
time_mmc=mmc dev 0; timer start; mmc read $loadaddr 0 5000; timer get
time_sd=mmc dev 1; timer start; mmc read $loadaddr 0 5000; timer get
vendor=qcom
